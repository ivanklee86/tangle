{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tangle","text":"<p>tangle (noun): A theoretical name for a group of octopuses since in the wild they are solitary creatures.</p> <p>Tangle makes using with multiple ArgoCDs in a hub and spoke architecture fun (\ud83c\udf89) and easy (\ud83d\ude05).  Its does this by:</p> <ul> <li>Showing <code>Applications</code> across multiple ArgoCD.</li> <li>Showing manifest diffs for many <code>Applications</code> across multiple ArgoCD.</li> <li>Working equally well for your CI/CD tooling (i.e. available as JSON APIs to consume from your tools) and for your humans (via a website that's easy to embed into existing tools).</li> <li>Does all those things with mechanisms (i.e. worker pools) to limit load on ArgoCD components</li> </ul> <p>Example: View all Applications with the <code>env:test</code> label</p> <p>Visiting <code>/applications?labels=env:test</code></p> <p></p> <p>Example: View diffs of all Applications with the <code>env:test</code> label from the <code>test_gitops</code> branch</p> <p>Visiting <code>/diffs?labels=env:test&amp;targetRef=test_gitops</code></p> <p></p> <p>Example: Using <code>tangle-cli</code> from your CI/CD pipelines</p> <p></p>"},{"location":"Installation/","title":"Server","text":"<p>Tangle is distributed as a Docker image and can be installed on Kubernetes via Helm charts.</p> <p>You can try out Tangle locally by: - Cloning the repository and opening it as a Dev Container. - Run <code>task services</code> to start a Kubernetes cluster with ArgoCD and a few <code>Applications</code>. - Start Tangle with the following command.</p> <pre><code>docker run --rm -it -v `pwd`/integration:/config -e TANGLE_CONFIG_PATH=/config/tangle.yaml --network=host --env-file .env ghcr.io/ivanklee86/tangle:latest\n</code></pre>"},{"location":"Installation/#cli","title":"CLI","text":""},{"location":"Installation/#homebrew","title":"Homebrew","text":"<pre><code>brew tap ivanklee86/homebrew-tap\nbrew install ivanklee86/tap/argonap\n</code></pre>"},{"location":"Installation/#docker","title":"Docker","text":"<p>The <code>tangle-cli</code> can be found in the <code>/usr/bin</code> folder of the Tangle Docker image.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#technology","title":"Technology","text":"<p>Tangle consists of two components:</p> <ul> <li>A server written in <code>Golang</code> that implements the API and serves web assets.<ul> <li>It uses the chi router since it offers useful, clearly beneficial features (route groups/middleware support) while being lightweight and using standard http handlers.</li> <li>It uses the ArgoCD SDK to talk to ArgoCD servers.</li> <li>Each ArgoCD API has a <code>alitto/pond</code> worker pool that allows us to balance concurrency against putting excess demand on the <code>repo</code> microservice..</li> <li>Endpoints are documented with OpenAPI and server includes an embedded Swagger UI in the <code>/swagger/</code> endpoint.</li> <li>It uses standard observability tools like:<ul> <li>hellofresh/health-go <code>/health</code> endpoints.</li> <li>Prometheus <code>/metrics</code> endpoint.</li> <li>httplog for logging.</li> </ul> </li> </ul> </li> <li>A static website written with <code>Svelte</code> and <code>Typescript</code>.<ul> <li>It uses flowbite-svelte as its design system.</li> </ul> </li> </ul> <p>Additionally it uses the following tools to improve our development experience:</p> <ul> <li>Github Actions for CI/CD.</li> <li>Development Containers to create a reproducable development environment.</li> <li>pre-commit to automate formatting &amp; checks.</li> <li>k3d to run Kubernetes cluster for testing locally &amp; in CI/CD.</li> <li>Task as a command runner/orchestrator.</li> <li>Air for live reloading.</li> <li>Goreleaser to build/distribute CLI.</li> <li>mkdocs &amp;&amp; mkdocs-material for documentation.</li> </ul>"},{"location":"architecture/#principles","title":"Principles","text":"<ol> <li>Features should have feature parity for CI/CD systems (via API and CLI tools) and humans (via website).</li> <li>Interactions with ArgoCD should not interfere with its core job (deploying stuff!).  Users should be able to set sane limits.</li> </ol>"},{"location":"cli/","title":"CLI","text":"<p>The <code>tangle-cli</code> allows you to easily leverage <code>tangle</code> in your CI/CD pipelines.  For example, you can quickly generate manifests for all your deplyments with <code>tangle-cli generate-manifests</code> and run kubeconform or conftest to give your developers fast feedback!</p> <p>Example usage: <pre><code>tangle-cli generate-manifests --server-address localhost:8081 --insecure --folder ./tmpdir --target-ref test_gitops --fail-on-error\n</code></pre></p>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#tangle-cli","title":"tangle-cli","text":"<pre><code>Usage:\n  tangle-cli [flags]\n  tangle-cli [command]\n\nAvailable Commands:\n  completion         Generate the autocompletion script for the specified shell\n  generate-manifests Generate manifests.\n  help               Help about any command\n\nFlags:\n  -h, --help                    help for tangle-cli\n      --insecure                Don't validate SSL certificate on client request\n      --server-address string   ArgoCD server address\n\nUse \"tangle-cli [command] --help\" for more information about a command.\n</code></pre>"},{"location":"cli/#tangle-cli-generate-manifests","title":"tangle-cli generate-manifests","text":"<pre><code>Generate manifests for ArgoCD applications.\n\nUsage:\n  tangle-cli generate-manifests [flags]\n\nFlags:\n      --exclude-label strings   Labels to exclude projects on in format 'key=value'.  Can be used multiple times.\n      --fail-on-error           Fail command if errors are found.\n      --folder string           Folder to generate manifests in.  Defaults to current folder.\n  -h, --help                    help for generate-manifests\n      --label strings           Labels to filter projects on in format 'key=value'.  Can be used multiple times.\n      --retries int             Number of retried for failed calls.  Must be between 0 (no retries) and 5.\n      --target-ref string       Git refernce to generate manifests.\n\nGlobal Flags:\n      --insecure                Don't validate SSL certificate on client request\n      --server-address string   ArgoCD server address\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The <code>tangle.yaml</code> file is the primary configuration file and specifies how Tangle connects to your ArgoCD servers.</p> <pre><code>argocds: # This section defines ArgoCD instances.\n  test:\n    address: \"localhost:8080\" # Address of the ArgoCD instance.  Should NOT have https://\n    insecure: true # Optional, can omit if ArgoCD has a proper certification.\n    authTokenEnvVar: \"ARGOCD_TOKEN\"  # Name of environment variable containing ArgoCD JWT.\n  prod:\n    address: \"localhost:8080\"\n    insecure: true\n    authTokenEnvVar: \"ARGOCD_PROD_TOKEN\"\n\nsortOrder:  # This section allows you to configure the order of ArgoCDs in the web UI.\n  - test\n  - prod\n</code></pre> <p>Additional configurations can be configured in the <code>tangle.yaml</code> or via environment variables with the <code>TANGLE_&lt;var&gt;</code> format.</p> Configuration Required? Default Value Description timeout No 60 (seconds) Timeout on ArgoCD queries listWorkers No 10 Control <code>List</code> parallelism manifestWorkers No 5 Controls <code>GetManifests</code> parallelism hardRefreshWorkers no 5 Controls <code>Get</code> with hard refresh parallelism"},{"location":"configuring_argocd/","title":"Configuring ArgoCD","text":"<p>Tangle uses a JWT to authenticate to ArgoCD. This can be configured in the Helm chart as follows: <pre><code>configs:\n  cm:\n    accounts.YOUR_ACCOUNT_NAME: apiKey\n\n  rbac:\n    policy.csv: |\n      p, role:tangle, applications, get, *, allow\n      g, YOUR_ACCOUNT_NAME, role:tangle\n</code></pre></p> <p>A JWT can be then generated using the ArgoCD CLI using the following command: <pre><code>argocd login # Using username/password or SSO\nargocd account generate-token --account YOUR_ACCOUNT\n</code></pre></p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#local-development-workflow","title":"Local Development Workflow","text":"<ol> <li>Start development container (preferably in Visual Studio Code).</li> <li>Run <code>task services</code> to start Kubernetes cluster, install ArgoCD + ingress controller, and test <code>Applications</code>.</li> <li>Run <code>task go:run</code> (to just run the server) or <code>task go:run:reloading</code> (reload the server).</li> <li>Run <code>task ts:install</code> to install Node dependencies.</li> <li>Run <code>task ts:dev</code> to start Svelte development server.</li> </ol>"},{"location":"contributing/#submitting-a-pr","title":"Submitting a PR","text":"<p>Pull requests are the best way to propose changes to the codebase (we use Github Flow). We actively welcome your pull requests:</p> <ol> <li>Fork the repo and create your branch from main.</li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> <li>Ensure the test suite passes.</li> <li>Make sure your code lints.</li> <li>Issue that pull request!</li> </ol>"},{"location":"contributing/#cutting-a-release","title":"Cutting a release","text":"<ol> <li>Land your changes on <code>main</code>.</li> <li>Create a Release with a new semver tag.</li> <li>Github Actions will build new Docker image &amp; CLI.</li> <li>Update the tangle-deployments repository with new application version (<code>Renovate</code> usually gives you a handy PR!).</li> <li>Bump chart version and create a new Helm release.</li> </ol>"},{"location":"contributing/#formatting-and-linting","title":"Formatting and Linting","text":"<p>Frontend and backend code both have automatic formatting and linting:</p> <p>For Go: <code>task go:fmt</code> &amp; <code>task go:lint</code> respectively. For frontend: <code>task ts:fmt</code> &amp; <code>task ts:lint</code> respectively.</p> <p>Where possible, rules are enforced with pre-commit hooks.</p>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Note: Both test suites will (eventually) include unit/integration tests.  You need to run the server locally for tests to pass!</p> <ul> <li>Go tests can be run with <code>task go:tests</code></li> <li>Frontend tests are WIP. \ud83d\ude2d</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Run <code>task python:serve</code> to run local document server.  Edit to your heart's content!</p>"},{"location":"operations/","title":"Operations","text":""},{"location":"operations/#health","title":"Health","text":"<p>Healthcheck can be found at <code>/health</code>.</p>"},{"location":"operations/#metrics","title":"Metrics","text":"<p>Prometheus metrics are exposed at <code>/metrics</code></p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#api","title":"API","text":"<p>Swagger documentation can be found at <code>/swagger</code>.</p>"},{"location":"usage/#web-ui","title":"Web UI","text":"<p>The Web UI is accessible at <code>/</code>.</p> <p>/applications takes the following URL parameters.  These can be hard-coded in your CI/CD system (e.g. based on environment variables).</p> Label Values example Description labels key1:value1,key2:value2 /applications?labels=foo:bar Labels on <code>Applications</code> to use for searching excludeLabels key1:value1,key2:value2 /applications?excludeLabels=foo:bar Labels on <code>Applications</code> to exclude refresh true/false /applications?refresh:true Toggle periodic updates on/off. <p>/diffs takes the following URL parameters.  These can be hard-coded in your CI/CD system (e.g. based on environment variables).</p> Label Values example Description labels key1:value1,key2:value2 /applications?labels=foo:bar Labels on <code>Applications</code> to use for searching excludeLabels key1:value1,key2:value2 /applications?excludeLabels=foo:bar Labels on <code>Applications</code> to exclude targetRef git ref /diffs?targetRef=your_branch Git reference to diff against"}]}